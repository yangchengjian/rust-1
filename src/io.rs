//! A module for writing TFRecords, Tensorflow's preferred on-disk data format.
//!
//! See the [tensorflow docs](https://www.tensorflow.org/api_guides/python/python_io#tfrecords-format-details) for details of this format.

use self::byteorder::WriteBytesExt;
use byteorder;
use crc::crc32;
use std::io;
use std::io::Write;

/// A type for writing bytes in the TFRecords format.
#[derive(Debug)]
pub struct RecordWriter<W: Write> {
    writer: W,
}

impl<W> RecordWriter<W>
where
    W: Write,
{
    /// Construct a new RecordWriter which writes to `writer`.
    pub fn new(writer: W) -> Self {
        RecordWriter { writer }
    }

    /// Write a complete TFRecord.
    pub fn write_record(&mut self, bytes: &[u8]) -> io::Result<()> {
        /* A TFRecords file contains a sequence of strings
        with CRC32C (32-bit CRC using the Castagnoli polynomial) hashes. Each record has the format

        uint64 length
        uint32 masked_crc32_of_length
        byte   data[length]
        uint32 masked_crc32_of_data
        and the records are concatenated together to produce the file. CRCs are described here [1], and the mask of a CRC is
        [1] https://en.wikipedia.org/wiki/Cyclic_redundancy_check
        masked_crc = ((crc >> 15) | (crc << 17)) + 0xa282ead8ul
        */
        let mut len_bytes = [0u8; 8];
        (&mut len_bytes[..]).write_u64::<byteorder::LittleEndian>(bytes.len() as u64)?;

        let masked_len_crc32c = Self::mask(crc32::checksum_castagnoli(&len_bytes));
        let mut len_crc32_bytes = [0u8; 4];
        (&mut len_crc32_bytes[..]).write_u32::<byteorder::LittleEndian>(masked_len_crc32c)?;

        let masked_bytes_crc32c = Self::mask(crc32::checksum_castagnoli(&bytes));
        let mut bytes_crc32_bytes = [0u8; 4];
        (&mut bytes_crc32_bytes[..]).write_u32::<byteorder::LittleEndian>(masked_bytes_crc32c)?;

        self.writer.write(&len_bytes)?;
        self.writer.write(&len_crc32_bytes)?;
        self.writer.write(bytes)?;
        self.writer.write(&bytes_crc32_bytes)?;
        Ok(())
    }

    fn mask(crc: u32) -> u32 {
        ((crc >> 15) | (crc << 17)).wrapping_add(0xa282ead8u32)
    }
}

////////////////////////

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;
    use std::io::Read;

    #[test]
    fn writer_identical_to_python() {
        let actual_filename = "test_resources/io/actual.tfrecord";
        // This file was generated by test_resources/io/python_writer.py
        let expected_filename = "test_resources/io/expected.tfrecord";
        {
            let f = ::std::fs::OpenOptions::new()
                .write(true)
                .create(true)
                .open(actual_filename)
                .unwrap();

            let mut record_writer = RecordWriter::new(::std::io::BufWriter::new(f));
            record_writer
                .write_record("The Quick Brown Fox".as_bytes())
                .unwrap();
        }

        let mut af = File::open(actual_filename).unwrap();
        let mut ef = File::open(expected_filename).unwrap();
        let mut actual = vec![0; 0];
        let mut expected = vec![0; 0];
        af.read_to_end(&mut actual).unwrap();
        ef.read_to_end(&mut expected).unwrap();

        assert_eq!(actual, expected);
    }

}
